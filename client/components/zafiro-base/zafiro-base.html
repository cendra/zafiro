<polymer-element name="zafiro-base" attributes="ngModel">
<script>
	Polymer({
		zs_: {
			attrs: ['ngModel'],
			origValues: {},
			reverseValues: {},
			evts: {},
			add: function(attr) {
				if(attr instanceof Array) {
					var self = this;
					attr.forEach(function(a) {
						if(typeof a == 'string') {
							self.attrs.push(a);
						} else if (typeof a == 'object') {
							for(var i in a) {
								!self.evts[i] && (self.evts[i] = []);
								self.evts[i].push(a[i]);
							}
						}
					});
				} else if(typeof attr == 'string') {
					this.attrs.push(attr);
				} else if (typeof attr == 'object') {
					for(var i in attr) {
						!this.evts[i] && (this.evts[i] = []);
						this.evts[i].push(attr[i]);
					}
				}
			}
		},
		scoped: function() {
			//Override this function to work with scoped elements
		},
		created: function() { 
			this.setAttribute('zf-polymer', true);
			!this.scope && this.fire("zafiro:base:scopeLookup", {elem: this});
		},
		ready: function() { 
			!this.scope && this.fire("zafiro:base:scopeLookup", {elem: this});
		},
		attached: function() { 
			!this.scope && this.fire("zafiro:base:scopeLookup", {elem: this});
		},
		domReady: function() { 
			!this.scope && this.fire("zafiro:base:scopeLookup", {elem: this});
		},
		setScope: function(scope) {
			this.scope = scope;
			var self = this;
			Array.prototype.forEach.call(this.attributes, function(attribute) {
				var m;
				if(m = attribute.nodeValue.match(/\{\{([\w-]+)\}\}/)) {
					try {
						m[1] = JSON.parse(m[1]);
					} catch(e) {

					}
					self.zs_.add(attribute.name);
					attribute.nodeValue = m[1];
				}
			});

			var mkObserver = function(obj, cb, path) {
				if(!obj || typeof obj != 'object') return;
				path = path || [];
				Object.observe(obj, function(changes) {
					changes.forEach(function(change) {
						if(['add', 'update'].indexOf(change.type) !== -1) {
							var tmpPath = [];
							path.forEach(function(step) {
								tmpPath.push(step);
							});
							tmpPath.push(change.name);
							mkObserver(obj[change.name], cb, tmpPath);
						}
					});
					cb && cb(changes, path);
				});
				for(var i in obj) {
					var tmpPath = [];
					path.forEach(function(step) {
						tmpPath.push(step);
					});
					tmpPath.push(i);
					mkObserver(obj[i], cb, tmpPath);
				}
			};

			this.zs_.attrs.forEach(function(attrName) {
				var scopeProp = self[attrName];
				self.zs_.origValues[attrName] = scopeProp;
				self.zs_.reverseValues[scopeProp] = attrName;
				self[attrName] = self.scope[scopeProp];

				mkObserver(self[attrName], function(changes, path) {
					changes.forEach(function(change) {
						var tmpPath = [];
						path.forEach(function(step) {
							tmpPath.push(step);
						});
						tmpPath.push(change.name);
						var scopeProp = self.zs_.origValues[tmpPath.shift()];
						if(scopeProp) {
							!self.scope.hasOwnProperty(scopeProp) && (self.scope[scopeProp] = {});
							var scopeElem = self.scope[scopeProp];
							while(tmpPath.length) {
								scopeProp = tmpPath.shift();
								!scopeElem.hasOwnProperty(scopeProp) && (scopeElem[scopeProp] = {});
								scopeElem = scopeElem[scopeProp];
							}
							if(change.object[change.name] != scopeElem) {
								scopeElem = change.object[change.name];
							}
						}
					});
				});

				mkObserver(self.scope[scopeProp], function(changes, path) {
					self.scope.$apply();
					changes.forEach(function(change) {
						var tmpPath = [];
						path.forEach(function(step) {
							tmpPath.push(step);
						});
						tmpPath.push(change.name);
						var selfProp = self.zs_.reverseValues[tmpPath.shift()];
						if(selfProp) {
							!self.hasOwnProperty(selfProp) && (self[selfProp] = {});
							var selfElem = self.scope[selfProp];
							while(tmpPath.length) {
								selfProp = tmpPath.shift();
								!selfElem.hasOwnProperty(selfProp) && (selfElem[selfProp] = {});
								selfElem = selfElem[selfProp];
							}
							if(change.object[change.name] != selfElem) {
								selfElem = change.object[change.name];
							}
						}
					});
				});

			});


			


			/*Object.observe(self, function(changes) {
				changes.forEach(function(change) {
					var scopeProp = self.zs_.origValues[change.name];
					if(scopeProp && change.object[change.name] != self.scope[scopeProp]) {
						self.scope[scopeProp] = change.object[change.name];
					}
				});
			});
			Object.observe(self.scope, function(changes) {
				self.scope.$apply();
				changes.forEach(function(change) {
					var attrName = self.zs_.reverseValues[change.name];
					if(attrName && change.object[change.name] != self[attrName]) {
						self[attrName] = change.object[change.name];
					}
				});
			});*/
			for(var i in this.zs_.evts) {
				this.addEventListener(i, function(e) {
					self.zs_.evts[i].forEach(function(evalAttr) {
						if(self[evalAttr] !== undefined)
							self.scope.$eval(self[evalAttr]);
					});
					e.preventDefault();
				});
			}
			if(this.scoped() !== false) {
				var zfElems = this.shadowRoot.querySelectorAll('*[zf-polymer=true]');
				Array.prototype.forEach.call(zfElems, function(zfElement) {
					zfElement.setScope(scope);
				});
			};
		}
	})
</script>
</polymer>